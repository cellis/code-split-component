/* @flow */

// This webpack plugin is responsible for mapping our moduleHash and chunkNames
// to the respective module and chunk identifiers that will be generated
// during the webpack bundling process (usually an incrementing integer value).
//
// It then binds the mapping object to either global/window so that it can be
// used within a browser/node context.
//
// Useful references:
// https://github.com/webpack/docs/wiki/How-to-write-a-plugin
// https://webpack.github.io/docs/api-in-modules.html

import serialize from 'serialize-javascript';
import { modulePathHash } from '../utils';
import { MODULE_CHUNK_MAPPING_IDENTIFIER } from '../constants';

type Options = {
  disabled?: boolean,
  role: 'server'|'client',
};

function CodeSplitPlugin(options: Options) {
  this.options = options || {};
}

CodeSplitPlugin.prototype.apply = function apply(compiler) {
  const options = this.options;

  if (options.disabled) {
    // Plugin has been disbaled, so do nothing.
    return;
  }

  const codeSplitWebpackRegistry = {
    modules: {},
    chunks: {},
  };
  const registerModule = (webpackId, moduleHash) => {
    codeSplitWebpackRegistry.modules[moduleHash] = webpackId;
  };
  const registerChunk = (webpackId, chunkName) => {
    codeSplitWebpackRegistry.chunks[chunkName] = webpackId;
  };

  compiler.plugin('after-plugins', () => {
    compiler.plugin('compilation', (compilation) => {
      compilation.mainTemplate.plugin('startup', function renderRegistry(source) {
        return this.asString([
          // This source will be injected _before_ entire bootrapping entry
          // script generated by webpack.  We use the " || " operator at the
          // end of the script to ensure that the webpack generated code will
          // be generated as our injected code returns "undefined" which causes
          // the OR expression to continue evaluating.  The webpack script
          // generally returns a value so we have to keep all of this in
          // expression format.
          `(function exposeCodeSplitWebpackRegistry() {
              const registry = ${serialize(codeSplitWebpackRegistry)};
              if (typeof global !== 'undefined') {
                global.${MODULE_CHUNK_MAPPING_IDENTIFIER} = registry;
              } else if (typeof window !== 'undefined') {
                window.${MODULE_CHUNK_MAPPING_IDENTIFIER} = registry;
              }
          }());`,
          source,
        ]);
      });
    });
  });

  compiler.plugin('compilation', (compilation) => {
    compilation.plugin('after-optimize-module-ids', (modules) => {
      modules.forEach((module) => {
        if (module.id !== null && module.libIdent) {
          const shouldRegisterModule =
            // We aren't interested in registering the node modules.
            module.resource.indexOf('node_modules') === -1
            // Or modules that are empty.
            && module.chunks.length > 0;
          if (shouldRegisterModule) {
            registerModule(module.id, modulePathHash(module.resource));
          }
        }
      }, this);
    });

    compilation.plugin('after-optimize-chunk-ids', (chunks) => {
      chunks.forEach((chunk) => {
        if (chunk.id !== null && chunk.name) {
          registerChunk(chunk.id, chunk.name);
        }
      });
    });
  });
};

module.exports = CodeSplitPlugin;

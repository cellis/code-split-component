'use strict';

var _utils = require('../utils');

var _constants = require('../constants');

// This webpack plugin is responsible for mapping our moduleHash and chunkNames
// to the respective module and chunk identifiers that will be generated
// during the webpack bundling process (usually an incrementing integer value).
//
// It then binds the mapping object to either global/window so that it can be
// used within a browser/node context.
//
// Useful references:
// https://github.com/webpack/docs/wiki/How-to-write-a-plugin
// https://webpack.github.io/docs/api-in-modules.html

function CodeSplitPlugin(options) {
  this.options = options || {};
}

CodeSplitPlugin.prototype.apply = function apply(compiler) {
  var _this = this;

  var options = this.options;

  if (options.disabled) {
    // Plugin has been disbaled, so do nothing.
    return;
  }

  var codeSplitWebpackRegistry = {
    modules: {},
    chunks: {}
  };
  var registerModule = function registerModule(webpackId, moduleHash) {
    codeSplitWebpackRegistry.modules[moduleHash] = webpackId;
  };
  var registerChunk = function registerChunk(webpackId, chunkName) {
    codeSplitWebpackRegistry.chunks[chunkName] = webpackId;
  };

  compiler.plugin('after-plugins', function () {
    compiler.plugin('compilation', function (compilation) {
      compilation.mainTemplate.plugin('startup', function renderRegistry(source) {
        return this.asString([
        // This source will be injected _before_ entire bootrapping entry
        // script generated by webpack.  We use the " || " operator at the
        // end of the script to ensure that the webpack generated code will
        // be generated as our injected code returns "undefined" which causes
        // the OR expression to continue evaluating.  The webpack script
        // generally returns a value so we have to keep all of this in
        // expression format.
        '(function exposeCodeSplitWebpackRegistry() {\n              const registry = ' + JSON.stringify(codeSplitWebpackRegistry) + ';\n              if (typeof global !== \'undefined\') {\n                global.' + _constants.MODULE_CHUNK_MAPPING_IDENTIFIER + ' = registry;\n              } else if (typeof window !== \'undefined\') {\n                window.' + _constants.MODULE_CHUNK_MAPPING_IDENTIFIER + ' = registry;\n              }\n          }());', source]);
      });
    });
  });

  compiler.plugin('compilation', function (compilation) {
    compilation.plugin('after-optimize-module-ids', function (modules) {
      modules.forEach(function (module) {
        if (module.id !== null && module.libIdent) {
          var shouldRegisterModule =
          // We aren't interested in registering the node modules.
          module.resource && module.resource.indexOf('node_modules') === -1
          // Or modules that are empty.
          && module.chunks && module.chunks.length > 0;
          if (shouldRegisterModule) {
            registerModule(module.id, (0, _utils.modulePathHash)(module.resource));
          }
        }
      }, _this);
    });

    compilation.plugin('after-optimize-chunk-ids', function (chunks) {
      chunks.forEach(function (chunk) {
        if (chunk.id !== null && chunk.name) {
          registerChunk(chunk.id, chunk.name);
        }
      });
    });
  });
};

module.exports = CodeSplitPlugin;